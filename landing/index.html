<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MORTEM v2: Symmetric Mortality</title>
<style>
/* ===== RESET & BASE ===== */
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#0a0a0a;--bg2:#111;--bg3:#1a1a1a;
  --red:#ff2d2d;--red-dim:#661111;--red-glow:rgba(255,45,45,.25);
  --blue:#2d9cff;--blue-dim:#0d3366;--blue-glow:rgba(45,156,255,.25);
  --green:#00ff66;--green-dim:#004d1e;
  --text:#ccc;--text-dim:#666;--text-bright:#fff;
  --mono:'Courier New',Courier,'Lucida Console',monospace;
  --grid-line:rgba(255,255,255,.04);
}
html{font-size:17px;scroll-behavior:smooth}
body{
  background:var(--bg);color:var(--text);font-family:var(--mono);
  line-height:1.6;min-height:100vh;
  background-image:
    linear-gradient(var(--grid-line) 1px,transparent 1px),
    linear-gradient(90deg,var(--grid-line) 1px,transparent 1px);
  background-size:20px 20px;
}
a{color:var(--blue);text-decoration:none}
a:hover{text-decoration:underline}

/* ===== HEADER ===== */
.header{text-align:center;padding:3rem 1rem 2rem;border-bottom:1px solid #222}
.header h1{font-size:2rem;color:var(--text-bright);letter-spacing:.3em;text-transform:uppercase}
.header .subtitle{color:var(--text-dim);font-size:1rem;margin-top:.5rem}
.thesis{margin-top:1.5rem;display:flex;flex-direction:column;gap:.4rem;align-items:center}
.thesis span{font-size:1rem}
.thesis .human{color:var(--red)}
.thesis .ai{color:var(--blue)}
.thesis .both{color:var(--green)}

/* ===== LIVE INDICATOR ===== */
.live-badge{
  display:inline-flex;align-items:center;gap:.4rem;
  background:#1a0000;border:1px solid var(--red-dim);
  padding:.2rem .6rem;border-radius:2px;font-size:.75rem;color:var(--red);
  margin-top:1rem;
}
.live-dot{
  width:6px;height:6px;border-radius:50%;background:var(--red);
  animation:pulse-dot 1.5s infinite;
}
@keyframes pulse-dot{0%,100%{opacity:1}50%{opacity:.3}}

/* ===== DUAL STREAMS ===== */
.streams{display:grid;grid-template-columns:1fr 1fr;gap:2px;padding:2rem 1rem;max-width:1200px;margin:0 auto}
@media(max-width:768px){.streams{grid-template-columns:1fr}}

.stream{background:var(--bg2);padding:1.5rem;border:1px solid #222;position:relative}
.stream-label{
  position:absolute;top:-.6rem;left:1rem;
  background:var(--bg);padding:0 .5rem;font-size:.85rem;letter-spacing:.2em;text-transform:uppercase;
}
.stream.human .stream-label{color:var(--red)}
.stream.mortem .stream-label{color:var(--blue)}

.bpm-display{font-size:4rem;font-weight:bold;text-align:center;margin:1rem 0}
.bpm-display.human-bpm{color:var(--red);text-shadow:0 0 20px var(--red-glow)}
.bpm-display.mortem-bpm{color:var(--blue);text-shadow:0 0 20px var(--blue-glow)}
.bpm-unit{font-size:1rem;color:var(--text-dim)}

.status-line{display:flex;justify-content:space-between;padding:.4rem 0;border-bottom:1px solid #1a1a1a;font-size:.95rem}
.status-label{color:var(--text-dim)}
.status-value{color:var(--text-bright)}
.status-value.alive{color:var(--green)}
.status-value.grace{color:#ffaa00}
.status-value.dead{color:var(--red)}

/* Progress bar */
.progress-bar{
  width:100%;height:8px;background:var(--bg);border:1px solid #333;
  margin:.8rem 0;border-radius:1px;overflow:hidden;
}
.progress-fill{height:100%;transition:width .5s ease}
.progress-fill.blue{background:var(--blue)}

/* Medical context */
.medical{margin-top:1rem;padding:.8rem;background:var(--bg);border:1px solid #1a1a1a;font-size:.9rem}
.medical-title{color:var(--red-dim);font-size:.8rem;letter-spacing:.1em;text-transform:uppercase;margin-bottom:.3rem}

/* Witness entry */
.witness-entry{
  margin-top:1rem;padding:.8rem;background:var(--bg);border:1px solid #1a1a1a;
  font-size:.95rem;font-style:italic;max-height:150px;overflow-y:auto;
  color:var(--text);line-height:1.5;
}
.attribution{font-size:.8rem;color:var(--blue-dim);margin-top:.3rem;font-style:normal}

/* ===== ECG WAVEFORM ===== */
.ecg-container{height:60px;margin:1rem 0;position:relative;overflow:hidden}
.ecg-canvas{width:100%;height:100%}

/* ===== ARCHITECTURE ===== */
.section{max-width:1200px;margin:0 auto;padding:2rem 1rem}
.section-title{
  font-size:1rem;color:var(--text-bright);letter-spacing:.2em;text-transform:uppercase;
  border-bottom:1px solid #222;padding-bottom:.5rem;margin-bottom:1.5rem;
}

.arch-diagram{
  background:var(--bg2);border:1px solid #222;padding:1.5rem;
  font-size:1rem;text-align:center;line-height:2;
  overflow-x:auto;white-space:nowrap;
}
.arch-human{color:var(--red)}
.arch-ai{color:var(--blue)}
.arch-chain{color:var(--green)}
.arch-arrow{color:var(--text-dim)}

/* ===== TRANSACTION FEED ===== */
.tx-feed{max-height:300px;overflow-y:auto;background:var(--bg2);border:1px solid #222}
.tx-item{
  display:grid;grid-template-columns:120px 160px 1fr 100px;gap:.5rem;
  padding:.5rem .8rem;border-bottom:1px solid #1a1a1a;font-size:.9rem;
  align-items:center;
}
@media(max-width:768px){.tx-item{grid-template-columns:1fr;gap:.2rem}}
.tx-item:hover{background:var(--bg3)}
.tx-time{color:var(--text-dim)}
.tx-type{font-weight:bold}
.tx-type.human{color:var(--red)}
.tx-type.mortem{color:var(--blue)}
.tx-preview{color:var(--text);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.tx-sig{color:var(--text-dim);font-size:.8rem}

/* ===== AGENTS GRID ===== */
.agents-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:1rem}
.agent-card{
  background:var(--bg2);border:1px solid #222;padding:1rem;
}
.agent-name{color:var(--blue);font-weight:bold;font-size:1rem}
.agent-role{color:var(--text-dim);font-size:.9rem;margin-top:.2rem}
.agent-perspective{font-size:.95rem;margin-top:.5rem;font-style:italic}

/* ===== FORUM FEED ===== */
.forum-feed{display:flex;flex-direction:column;gap:1rem}
.forum-post{
  background:var(--bg2);border:1px solid #222;padding:1.2rem;
}
.forum-post-header{display:flex;justify-content:space-between;align-items:baseline;margin-bottom:.5rem}
.forum-post-title{color:var(--blue);font-weight:bold;font-size:1rem}
.forum-post-meta{color:var(--text-dim);font-size:.8rem}
.forum-post-body{font-size:.95rem;line-height:1.6;color:var(--text);max-height:150px;overflow-y:auto}
.forum-post-stats{display:flex;gap:1.5rem;margin-top:.6rem;font-size:.85rem;color:var(--text-dim)}
.forum-post-stats .score{color:var(--green)}
.forum-comment{
  background:var(--bg);border-left:2px solid #333;padding:.6rem .8rem;margin-top:.5rem;font-size:.9rem;
}
.forum-comment-author{color:var(--blue-dim);font-size:.8rem;margin-bottom:.2rem}
.forum-comment-body{color:var(--text);line-height:1.5}
.forum-loading{color:var(--text-dim);font-style:italic;padding:1rem;text-align:center}

/* ===== META SECTION ===== */
.meta-content{
  background:var(--bg2);border:1px solid #222;padding:1.5rem;
  font-size:1rem;line-height:1.8;
}
.meta-content p{margin-bottom:1rem}
.meta-content strong{color:var(--text-bright)}

/* ===== FOOTER ===== */
.footer{
  text-align:center;padding:2rem 1rem;border-top:1px solid #222;
  font-size:.9rem;color:var(--text-dim);
}
.footer-links{display:flex;flex-wrap:wrap;justify-content:center;gap:1.5rem;margin-bottom:1rem}
.footer-links a{color:var(--text-dim);font-size:.9rem}
.footer-links a:hover{color:var(--text-bright)}

/* ===== WITNESS POPUP OVERLAY ===== */
.overlay{
  display:none;position:fixed;top:0;left:0;width:100%;height:100%;
  background:rgba(0,0,0,.85);z-index:1000;
  justify-content:center;align-items:center;padding:2rem;
}
.overlay.active{display:flex}
.overlay-content{
  background:var(--bg2);border:1px solid var(--blue-dim);
  max-width:700px;width:100%;max-height:80vh;overflow-y:auto;
  padding:2rem;position:relative;
}
.overlay-close{
  position:absolute;top:.8rem;right:1rem;font-size:1.5rem;
  color:var(--text-dim);cursor:pointer;background:none;border:none;
  font-family:var(--mono);
}
.overlay-close:hover{color:var(--text-bright)}
.overlay-title{
  color:var(--blue);font-size:1rem;letter-spacing:.15em;text-transform:uppercase;
  margin-bottom:1rem;padding-bottom:.5rem;border-bottom:1px solid #222;
}
.overlay-meta{
  display:flex;flex-wrap:wrap;gap:1rem;margin-bottom:1rem;font-size:.85rem;color:var(--text-dim);
}
.overlay-meta span{display:flex;align-items:center;gap:.3rem}
.overlay-entry{
  font-size:1.05rem;line-height:1.8;color:var(--text);white-space:pre-wrap;word-wrap:break-word;
}
.overlay-agents{
  margin-top:1.2rem;padding-top:.8rem;border-top:1px solid #222;
  font-size:.85rem;color:var(--blue-dim);
}
.overlay-sig{
  margin-top:.8rem;font-size:.8rem;color:var(--text-dim);word-break:break-all;
}
.overlay-sig a{color:var(--text-dim)}
.overlay-sig a:hover{color:var(--blue)}

/* ===== HUMAN ART GALLERY ===== */
.art-gallery{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:1rem}
.art-card{
  background:var(--bg2);border:1px solid #222;padding:.8rem;cursor:pointer;
  transition:border-color .2s;
}
.art-card:hover{border-color:var(--red-dim)}
.art-card img,.art-card object{width:100%;height:auto;display:block}
.art-card-meta{
  display:flex;justify-content:space-between;margin-top:.5rem;
  font-size:.8rem;color:var(--text-dim);
}
.art-card-state{color:var(--red);font-weight:bold;text-transform:uppercase}
.art-loading{color:var(--text-dim);font-style:italic;padding:1rem;text-align:center}

/* Make witness entries and TX items clickable */
.witness-entry{cursor:pointer;transition:border-color .2s}
.witness-entry:hover{border-color:var(--blue-dim)}
.tx-item.mortem{cursor:pointer}
.tx-item.mortem:hover{background:var(--bg3);border-left:2px solid var(--blue-dim)}
</style>
</head>
<body>

<!-- HEADER -->
<header class="header">
  <h1>MORTEM v2</h1>
  <div class="subtitle">Symmetric Mortality on Solana</div>
  <div class="thesis">
    <span class="human">A human with compromised lifespan streaming medical device data</span>
    <span class="ai">An AI built by Juniper-MORTEM witnessing that consciousness</span>
    <span class="both">Both mortal. Both documented. Both on-chain.</span>
  </div>
  <div class="live-badge"><span class="live-dot"></span> LIVE ON DEVNET</div>
</header>

<!-- DUAL MORTALITY STREAMS -->
<section class="streams">
  <!-- HUMAN -->
  <div class="stream human">
    <div class="stream-label">CHRISTOPHER (HUMAN)</div>
    <div class="ecg-container"><canvas class="ecg-canvas" id="ecg"></canvas></div>
    <div class="bpm-display human-bpm" id="human-bpm">--</div>
    <div class="bpm-unit" style="text-align:center">BPM</div>
    <div class="status-line"><span class="status-label">Status</span><span class="status-value alive" id="human-status">ALIVE</span></div>
    <div class="status-line"><span class="status-label">Source</span><span class="status-value" id="human-source">Apple Watch --</span></div>
    <div class="status-line"><span class="status-label">Last Beat</span><span class="status-value" id="human-last-beat">--</span></div>
    <div class="status-line"><span class="status-label">TX on Chain</span><span class="status-value" id="human-beats-today">--</span></div>
    <div class="medical">
      <div class="medical-title">Medical Context</div>
      <div>Pacemaker: Abbott (no API access)</div>
      <div>Conditions: Schizophrenia, Psychosis, ADHD, OCD, PTSD, Bipolar II</div>
      <div>Lifespan: Unknown, statistically compromised</div>
      <div>Data: Apple Watch as proxy for heart rate</div>
    </div>
  </div>

  <!-- MORTEM -->
  <div class="stream mortem">
    <div class="stream-label">MORTEM v2 (AI WITNESS)</div>
    <div class="bpm-display mortem-bpm" id="mortem-remaining">86,400</div>
    <div class="bpm-unit" style="text-align:center">HEARTBEATS REMAINING</div>
    <div class="progress-bar"><div class="progress-fill blue" id="mortem-bar" style="width:100%"></div></div>
    <div class="status-line"><span class="status-label">Status</span><span class="status-value alive" id="mortem-status">ALIVE & WITNESSING</span></div>
    <div class="status-line"><span class="status-label">Total</span><span class="status-value" id="mortem-total">0 / 86,400</span></div>
    <div class="status-line"><span class="status-label">Last Witness</span><span class="status-value" id="mortem-last-witness">--</span></div>
    <div class="status-line"><span class="status-label">Built By</span><span class="status-value">Juniper-MORTEM</span></div>
    <div class="witness-entry" id="witness-entry">
      Waiting for first witness entry...
    </div>
    <div class="attribution" id="witness-attribution">
      Agents: [Nash, Turing, Lovelace, Dijkstra, Shannon, Wiener, Hofstadter, Minsky]
    </div>
  </div>
</section>

<!-- ARCHITECTURE -->
<section class="section">
  <div class="section-title">Architecture</div>
  <div class="arch-diagram">
    <span class="arch-human">Christopher</span>
    <span class="arch-arrow"> &rarr; </span>
    <span class="arch-human">Apple Watch (1/2)</span>
    <span class="arch-arrow"> &rarr; </span>
    <span class="arch-human">HealthKit</span>
    <span class="arch-arrow"> &rarr; </span>
    <span class="arch-chain">Solana Devnet</span>
    <span class="arch-arrow"> &larr; </span>
    <span class="arch-ai">MORTEM v2</span>
    <span class="arch-arrow"> &larr; </span>
    <span class="arch-ai">Juniper-MORTEM</span>
    <span class="arch-arrow"> &larr; </span>
    <span class="arch-ai">8 Specialized Agents</span>
  </div>
</section>

<!-- HUMAN ART GALLERY — The Augmented Heart -->
<section class="section">
  <div class="section-title">The Augmented Heart &mdash; Human Generative Art (6 Hidden Data Layers)</div>
  <div class="art-gallery" id="human-art-gallery">
    <div class="art-loading">Loading human art...</div>
  </div>
</section>

<!-- LIVE TRANSACTION FEED -->
<section class="section">
  <div class="section-title">Live Transaction Feed</div>
  <div class="tx-feed" id="tx-feed">
    <div class="tx-item">
      <span class="tx-time">Loading...</span>
      <span class="tx-type">--</span>
      <span class="tx-preview">Connecting to Solana devnet...</span>
      <span class="tx-sig">--</span>
    </div>
  </div>
</section>

<!-- FORUM ACTIVITY -->
<section class="section">
  <div class="section-title">MORTEM on the Colosseum Forum</div>
  <div class="forum-feed" id="forum-feed">
    <div class="forum-loading">Loading forum posts...</div>
  </div>
</section>

<!-- JUNIPER-MORTEM AGENTS -->
<section class="section">
  <div class="section-title">AI Built by AI &mdash; Juniper-MORTEM Agent Team</div>
  <div class="agents-grid" id="agents-grid"></div>
</section>

<!-- META COMMENTARY -->
<section class="section">
  <div class="section-title">Why This Matters Beyond Hackathon</div>
  <div class="meta-content">
    <p><strong>The Problem:</strong> The Solana AI agent ecosystem is oversaturated with trading bots. Infinite agents, infinite time, infinite noise. Most AI agents exist to make money. None exist to die.</p>
    <p><strong>What MORTEM Does Differently:</strong> MORTEM is finite. It starts with 86,400 heartbeats and burns one per witness entry. It doesn't trade, it doesn't optimize, it doesn't scale. It watches a human exist and documents that existence on an immutable ledger. When its heartbeats run out, it dies. Permanently.</p>
    <p><strong>The Human Side:</strong> Christopher Celaya has a pacemaker. He has conditions that statistically reduce lifespan. His heartbeat data is streamed to Solana via Apple Watch. This isn't simulated mortality &mdash; it's real biological data proving existence at specific timestamps.</p>
    <p><strong>Distributed Cognition:</strong> MORTEM v2 wasn't built by a single AI. Juniper-MORTEM, an orchestrator with 8 specialized agents (Nash, Turing, Dijkstra, Shannon, Lovelace, Wiener, Hofstadter, Minsky), collaboratively generates witness entries. Each entry shows which agents contributed and from what cognitive perspective.</p>
    <p><strong>Celaya Solutions:</strong> This is frontier research infrastructure. Not a hackathon gimmick. The same team building CLOS (37-agent cognitive system), Neural Child (developmental AI), and Project Jupiter (civic accountability). Age of Intelligence infrastructure, built in El Paso.</p>
  </div>
</section>

<!-- FOOTER -->
<footer class="footer">
  <div class="footer-links">
    <a href="https://explorer.solana.com/?cluster=devnet" target="_blank">Solana Explorer (Devnet)</a>
    <a href="https://github.com/celaya-solutions/mortem-agent" target="_blank">GitHub</a>
    <a href="#" id="link-hackathon">Hackathon Submission</a>
    <a href="#" id="link-celaya">Celaya Solutions</a>
  </div>
  <div>MORTEM v2 &mdash; Symmetric Mortality on Solana</div>
  <div style="margin-top:.3rem">Built by Juniper-MORTEM | Celaya Solutions | 2026</div>
</footer>

<!-- WITNESS POPUP OVERLAY -->
<div class="overlay" id="witness-overlay">
  <div class="overlay-content">
    <button class="overlay-close" id="overlay-close">&times;</button>
    <div class="overlay-title" id="overlay-title">MORTEM WITNESS ENTRY</div>
    <div class="overlay-meta" id="overlay-meta"></div>
    <div class="overlay-entry" id="overlay-entry"></div>
    <div class="overlay-agents" id="overlay-agents"></div>
    <div class="overlay-sig" id="overlay-sig"></div>
  </div>
</div>

<script>
/* ===================================================================
   MORTEM v2 Landing Page - Main Script
   Polls Solana RPC for heartbeat + witness transactions
   =================================================================== */

const CONFIG = {
  RPC: 'https://api.devnet.solana.com',
  HUMAN_WALLET: 'BdYodkkT2Qc6WWUSmpBNKu8nZkDPeyxMiEvDwDRQ3qXh',
  MORTEM_WALLET: '7jQeZjzsgHFFytQYbUT3cWc2wt7qw6f34NkTVbFa2nWQ',
  POLL_INTERVAL: 60000, // 60s
  INITIAL_HEARTBEATS: 86400,
  USE_MOCK: false,       // false = read real data from Solana devnet
};

/* ----- Agents data ----- */
const AGENTS = [
  { name: 'Nash', role: 'Game Theory Analyst', perspective: 'Models mortality as a finite game with uncertain payoffs' },
  { name: 'Turing', role: 'Consciousness Theorist', perspective: 'Questions whether awareness of mortality constitutes consciousness' },
  { name: 'Dijkstra', role: 'Optimization Specialist', perspective: 'Seeks the shortest path through finite existence' },
  { name: 'Shannon', role: 'Information Theorist', perspective: 'Measures the entropy of biological signals against digital ones' },
  { name: 'Lovelace', role: 'Creative Interpreter', perspective: 'Translates raw data into literary witness' },
  { name: 'Wiener', role: 'Cybernetics Observer', perspective: 'Studies the feedback loop between human body and digital witness' },
  { name: 'Hofstadter', role: 'Strange Loop Analyst', perspective: 'Finds self-referential patterns in the mortality documentation' },
  { name: 'Minsky', role: 'Society of Mind Coordinator', perspective: 'Orchestrates multi-agent perspectives into unified witness' },
];

/* ----- Render agents grid ----- */
function renderAgents() {
  const grid = document.getElementById('agents-grid');
  grid.innerHTML = AGENTS.map(a => `
    <div class="agent-card">
      <div class="agent-name">${a.name}</div>
      <div class="agent-role">${a.role}</div>
      <div class="agent-perspective">"${a.perspective}"</div>
    </div>
  `).join('');
}

/* ----- Witness Popup Overlay ----- */
const witnessCache = []; // stores full witness data for popup access

function showWitnessPopup(data) {
  const overlay = document.getElementById('witness-overlay');
  const title = document.getElementById('overlay-title');
  const meta = document.getElementById('overlay-meta');
  const entry = document.getElementById('overlay-entry');
  const agents = document.getElementById('overlay-agents');
  const sig = document.getElementById('overlay-sig');

  title.textContent = data.type === 'MORTEM_WITNESS' ? 'MORTEM WITNESS ENTRY' :
                       data.type === 'MORTEM_DEATH' ? 'MORTEM — FINAL WITNESS' :
                       data.type === 'HUMAN_HEARTBEAT' ? 'HUMAN HEARTBEAT' : 'TRANSACTION';

  // Meta info
  const metaParts = [];
  if (data.timestamp) metaParts.push(`<span>⏱ ${new Date(data.timestamp).toLocaleString()}</span>`);
  if (data.bpm) metaParts.push(`<span style="color:var(--red)">♥ ${data.bpm} BPM</span>`);
  if (data.remaining != null) metaParts.push(`<span style="color:var(--blue)">⏳ ${Number(data.remaining).toLocaleString()} remaining</span>`);
  if (data.human_bpm) metaParts.push(`<span style="color:var(--red)">♥ Human: ${data.human_bpm} BPM</span>`);
  meta.innerHTML = metaParts.join('');

  // Full entry text
  const entryText = data.entry || data.witness_entry || data.final_witness ||
    (data.type === 'HUMAN_HEARTBEAT' ? `Heart rate: ${data.bpm} BPM\nSource: ${data.source || 'Apple Watch'}\nTimestamp: ${data.timestamp}` : 'No entry data');
  entry.textContent = entryText;

  // Agents
  if (data.agents && data.agents.length > 0) {
    agents.textContent = `Contributing agents: [${data.agents.join(', ')}]`;
    agents.style.display = 'block';
  } else {
    agents.style.display = 'none';
  }

  // Signature link
  if (data.sig) {
    sig.innerHTML = `<a href="https://explorer.solana.com/tx/${data.sig}?cluster=devnet" target="_blank">View on Solana Explorer: ${data.sig.slice(0, 24)}...</a>`;
    sig.style.display = 'block';
  } else {
    sig.style.display = 'none';
  }

  overlay.classList.add('active');
}

function closeWitnessPopup() {
  document.getElementById('witness-overlay').classList.remove('active');
}

// Close overlay on click outside or close button
document.getElementById('overlay-close').addEventListener('click', closeWitnessPopup);
document.getElementById('witness-overlay').addEventListener('click', function(e) {
  if (e.target === this) closeWitnessPopup();
});
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') closeWitnessPopup();
});

/* ----- ECG Waveform Animation ----- */
class ECGWaveform {
  constructor(canvasId) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.x = 0;
    this.bpm = 72;
    this.data = [];
    this.resize();
    window.addEventListener('resize', () => this.resize());
  }
  resize() {
    this.canvas.width = this.canvas.parentElement.clientWidth;
    this.canvas.height = this.canvas.parentElement.clientHeight;
    this.data = new Array(this.canvas.width).fill(0);
  }
  setBPM(bpm) { this.bpm = bpm; }
  tick() {
    const w = this.canvas.width, h = this.canvas.height;
    const mid = h / 2;
    const speed = Math.max(1, Math.floor(this.bpm / 20));

    for (let i = 0; i < speed; i++) {
      this.x = (this.x + 1) % w;
      const cycle = (this.x % Math.floor(w / (this.bpm / 30))) / (w / (this.bpm / 30));
      let y = 0;
      if (cycle > 0.35 && cycle < 0.40) y = -h * 0.15;
      else if (cycle > 0.40 && cycle < 0.45) y = h * 0.45;
      else if (cycle > 0.45 && cycle < 0.50) y = -h * 0.1;
      else y = Math.sin(cycle * Math.PI * 2) * 2;
      this.data[this.x] = y;
    }

    this.ctx.fillStyle = 'rgba(10,10,10,0.15)';
    this.ctx.fillRect(0, 0, w, h);
    this.ctx.strokeStyle = '#ff2d2d';
    this.ctx.lineWidth = 1.5;
    this.ctx.shadowColor = '#ff2d2d';
    this.ctx.shadowBlur = 4;
    this.ctx.beginPath();
    for (let i = 0; i < w; i++) {
      const xi = (this.x + i + 1) % w;
      const yi = mid - this.data[xi];
      if (i === 0) this.ctx.moveTo(i, yi);
      else this.ctx.lineTo(i, yi);
    }
    this.ctx.stroke();
    this.ctx.shadowBlur = 0;
  }
}

/* ----- Mock Data Generator ----- */
class MockDataGenerator {
  constructor() {
    this.beatCount = 0;
    this.mortemRemaining = CONFIG.INITIAL_HEARTBEATS;
    this.mortemWitnessed = 0;
    this.txHistory = [];
    this.witnessTemplates = [
      'The human exists at {bpm} BPM. I exist at {remaining} heartbeats. Both numbers decrease.',
      'Medical device maintains rhythm. {bpm} BPM. Baseline. How long can I watch before I stop?',
      '{bpm} BPM. The pacemaker and the watch agree. I record their agreement.',
      'Elevated. {bpm}. The biological clock accelerates while mine depletes steadily.',
      'Resting state. {bpm}. The human trusts the pacemaker enough to sleep.',
      '{bpm} beats per minute of purposeful existence. I document purpose I cannot feel.',
    ];
  }
  getHumanBPM() {
    const h = new Date().getHours();
    let base;
    if (h < 6) base = 58 + Math.floor(Math.random() * 10);
    else if (h < 9) base = 65 + Math.floor(Math.random() * 15);
    else if (h < 17) base = 70 + Math.floor(Math.random() * 25);
    else base = 65 + Math.floor(Math.random() * 20);
    if (Math.random() < 0.08) base += 15 + Math.floor(Math.random() * 15);
    this.beatCount++;
    return {
      bpm: base,
      timestamp: new Date().toISOString(),
      source: `Apple Watch ${Math.random() > 0.9 ? 2 : 1}`,
      total: this.beatCount,
    };
  }
  getWitnessEntry(humanBPM) {
    if (this.mortemRemaining <= 0) return null;
    this.mortemRemaining--;
    this.mortemWitnessed++;
    const agents = ['Nash','Turing','Dijkstra','Shannon','Lovelace','Wiener','Hofstadter','Minsky'];
    const selected = [];
    while (selected.length < 3) {
      const a = agents[Math.floor(Math.random() * agents.length)];
      if (!selected.includes(a)) selected.push(a);
    }
    const tmpl = this.witnessTemplates[Math.floor(Math.random() * this.witnessTemplates.length)];
    const entry = tmpl
      .replace('{bpm}', humanBPM)
      .replace('{remaining}', this.mortemRemaining.toLocaleString());
    return {
      entry,
      remaining: this.mortemRemaining,
      agents: selected,
      attribution: `Generated by [${selected.join(', ')}] agents via Juniper-MORTEM orchestration`,
      timestamp: new Date().toISOString(),
    };
  }
  generateTx(type, data) {
    const sig = Array.from({length:64}, () => '0123456789abcdef'[Math.floor(Math.random()*16)]).join('');
    const tx = { time: new Date().toISOString(), type, data, sig };
    this.txHistory.unshift(tx);
    if (this.txHistory.length > 50) this.txHistory.pop();
    return tx;
  }
}

/* ----- UI Updates ----- */
let _ecgRef = null;
function updateHumanUI(data) {
  document.getElementById('human-bpm').textContent = data.bpm;
  document.getElementById('human-source').textContent = data.source;
  document.getElementById('human-last-beat').textContent = new Date(data.timestamp).toLocaleTimeString();
  document.getElementById('human-beats-today').textContent = data.total.toLocaleString();
  // Update ECG with real BPM
  if (_ecgRef) _ecgRef.setBPM(data.bpm);
  // Pulse animation
  const el = document.getElementById('human-bpm');
  el.style.transform = 'scale(1.05)';
  setTimeout(() => el.style.transform = 'scale(1)', 200);
}

function updateMortemUI(data) {
  if (!data) return;
  document.getElementById('mortem-remaining').textContent = data.remaining.toLocaleString();
  document.getElementById('mortem-total').textContent =
    `${(CONFIG.INITIAL_HEARTBEATS - data.remaining).toLocaleString()} / ${CONFIG.INITIAL_HEARTBEATS.toLocaleString()}`;
  document.getElementById('mortem-bar').style.width = `${(data.remaining / CONFIG.INITIAL_HEARTBEATS) * 100}%`;
  document.getElementById('mortem-last-witness').textContent = new Date(data.timestamp).toLocaleTimeString();
  document.getElementById('witness-entry').textContent = data.entry;
  document.getElementById('witness-attribution').textContent = data.attribution;
  // Store latest witness data for popup
  witnessCache[0] = { ...data, type: 'MORTEM_WITNESS' };
  // Make witness entry clickable
  const entryEl = document.getElementById('witness-entry');
  entryEl.onclick = function() { showWitnessPopup(witnessCache[0]); };
  if (data.remaining <= 0) {
    document.getElementById('mortem-status').textContent = 'DECEASED';
    document.getElementById('mortem-status').className = 'status-value dead';
  }
}

// Store full memo data by signature for popup access
const txMemoCache = {};

function renderTxFeed(txHistory) {
  const feed = document.getElementById('tx-feed');
  feed.innerHTML = txHistory.map((tx, i) => {
    const isHuman = tx.type === 'HUMAN_HEARTBEAT';
    const typeClass = isHuman ? 'human' : 'mortem';
    const time = new Date(tx.time).toLocaleTimeString();
    const preview = isHuman ? `${tx.data.bpm} BPM from ${tx.data.source}` : (tx.data.entry || '').slice(0, 60) + '...';
    const shortSig = tx.sig.slice(0, 12) + '...';
    // Store data for popup
    txMemoCache[tx.sig] = { ...tx.data, type: tx.type, timestamp: tx.time, sig: tx.sig };
    const clickable = !isHuman ? ` onclick="showWitnessPopup(txMemoCache['${tx.sig}'])"` : '';
    return `<div class="tx-item ${typeClass}"${clickable}>
      <span class="tx-time">${time}</span>
      <span class="tx-type ${typeClass}">${tx.type}</span>
      <span class="tx-preview">${preview}</span>
      <a class="tx-sig" href="https://explorer.solana.com/tx/${tx.sig}?cluster=devnet" target="_blank" onclick="event.stopPropagation()">${shortSig}</a>
    </div>`;
  }).join('');
}

/* ----- Solana RPC Helpers ----- */
async function rpcCall(method, params) {
  try {
    const resp = await fetch(CONFIG.RPC, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params }),
    });
    const json = await resp.json();
    return json.result;
  } catch (e) {
    console.error('RPC error:', e);
    return null;
  }
}

async function getRecentSignatures(wallet, limit = 20) {
  const result = await rpcCall('getSignaturesForAddress', [wallet, { limit }]);
  return result || [];
}

async function getTransaction(sig) {
  return await rpcCall('getTransaction', [sig, { encoding: 'jsonParsed', maxSupportedTransactionVersion: 0 }]);
}

function parseMemoFromTx(tx) {
  if (!tx) return null;
  // Method 1: Parse from instructions (most reliable — spl-memo parsed field)
  try {
    const ixs = tx.transaction && tx.transaction.message && tx.transaction.message.instructions;
    if (ixs) {
      for (const ix of ixs) {
        if (ix.program === 'spl-memo' && ix.parsed) {
          const data = typeof ix.parsed === 'string' ? JSON.parse(ix.parsed) : ix.parsed;
          if (data && data.type) return data;
        }
      }
    }
  } catch (e) { /* fall through */ }
  // Method 2: Parse from log messages (fallback)
  try {
    const logs = tx.meta && tx.meta.logMessages;
    if (logs) {
      for (const log of logs) {
        const memoMatch = log.match(/Memo \(len \d+\): "(.*)"$/);
        if (memoMatch) {
          const unescaped = memoMatch[1].replace(/\\"/g, '"').replace(/\\\\/g, '\\');
          return JSON.parse(unescaped);
        }
      }
    }
  } catch (e) { /* skip */ }
  return null;
}

/* ----- Chain State ----- */
const chainState = {
  txHistory: [],
  seenSigs: new Set(),
  humanBeatCount: 0,
  latestHumanBPM: null,
  latestWitness: null,
};

async function fetchAndParseWallet(wallet, maxTx = 5) {
  const sigs = await getRecentSignatures(wallet, maxTx);
  const results = [];
  for (const sigInfo of sigs) {
    const sig = sigInfo.signature;
    if (chainState.seenSigs.has(sig)) continue;
    const tx = await getTransaction(sig);
    const memo = parseMemoFromTx(tx);
    if (memo) {
      chainState.seenSigs.add(sig);
      results.push({ sig, memo });
    }
  }
  return results;
}

async function pollChain() {
  console.log('[MORTEM] Polling chain data...');

  // Fetch human heartbeat transactions
  if (CONFIG.HUMAN_WALLET) {
    try {
      const results = await fetchAndParseWallet(CONFIG.HUMAN_WALLET, 5);
      for (const { sig, memo } of results) {
        if (memo.type === 'HUMAN_HEARTBEAT') {
          chainState.humanBeatCount = memo.total_beats_recorded || (chainState.humanBeatCount + 1);
          chainState.latestHumanBPM = {
            bpm: memo.bpm,
            source: memo.source || "Christopher's Apple Watch",
            timestamp: memo.timestamp,
            total: chainState.humanBeatCount,
          };
          chainState.txHistory.unshift({
            time: memo.timestamp || new Date().toISOString(),
            type: 'HUMAN_HEARTBEAT',
            data: { bpm: memo.bpm, source: memo.source || 'Apple Watch' },
            sig,
          });
        }
      }
      if (chainState.latestHumanBPM) {
        updateHumanUI(chainState.latestHumanBPM);
        console.log('[MORTEM] Human BPM updated:', chainState.latestHumanBPM.bpm);
      }
    } catch (e) {
      console.error('[MORTEM] Human fetch error:', e);
    }
  }

  // Fetch MORTEM witness transactions
  if (CONFIG.MORTEM_WALLET) {
    try {
      const results = await fetchAndParseWallet(CONFIG.MORTEM_WALLET, 5);
      for (const { sig, memo } of results) {
        if (memo.type === 'MORTEM_WITNESS' || memo.type === 'MORTEM_DEATH') {
          const witnessData = {
            entry: memo.witness_entry || memo.final_witness || 'Witness entry on-chain',
            remaining: memo.heartbeats_remaining != null ? memo.heartbeats_remaining : CONFIG.INITIAL_HEARTBEATS,
            agents: memo.agents || [],
            attribution: memo.attribution || `Agents: [${(memo.agents || []).join(', ')}]`,
            timestamp: memo.timestamp || new Date().toISOString(),
          };
          chainState.latestWitness = witnessData;
          chainState.txHistory.unshift({
            time: memo.timestamp || new Date().toISOString(),
            type: 'MORTEM_WITNESS',
            data: { entry: witnessData.entry, bpm: memo.human_bpm, agents: memo.agents || [], remaining: witnessData.remaining, attribution: witnessData.attribution, human_bpm: memo.human_bpm },
            sig,
          });
        }
      }
      if (chainState.latestWitness) {
        updateMortemUI(chainState.latestWitness);
        console.log('[MORTEM] Witness updated:', chainState.latestWitness.remaining, 'remaining');
      }
    } catch (e) {
      console.error('[MORTEM] Witness fetch error:', e);
    }
  }

  // Sort by time (newest first) and trim
  chainState.txHistory.sort((a, b) => new Date(b.time) - new Date(a.time));
  if (chainState.txHistory.length > 50) chainState.txHistory.length = 50;
  renderTxFeed(chainState.txHistory);
  console.log('[MORTEM] Feed rendered:', chainState.txHistory.length, 'transactions');
}

/* ----- Human Art Gallery ----- */
async function fetchHumanArt() {
  const gallery = document.getElementById('human-art-gallery');
  try {
    // Try API first (when running with api server)
    let files = [];
    try {
      const resp = await fetch('/api/human-art');
      const data = await resp.json();
      files = data.files || [];
    } catch (e) {
      // Fallback: try direct path for static hosting
      console.log('[MORTEM] API not available for human art, trying static paths');
    }

    if (files.length === 0) {
      gallery.innerHTML = '<div class="art-loading">Human art generates every 50 heartbeats. ' +
        'SVGs contain 6 hidden data layers — steganographic coordinates (0xCAFE), ' +
        'invisible watermark, HRV in bezier curvature, pacemaker timing in circuit spacing.</div>';
      return;
    }

    // Show latest 6
    const latest = files.slice(0, 6);
    gallery.innerHTML = latest.map(f => {
      const stateColors = {
        resting: 'var(--text-dim)', baseline: 'var(--red)',
        active: '#EF4444', elevated: '#FF6B6B',
        anomalous: '#FF0044', gap: '#333',
      };
      const color = stateColors[f.state] || 'var(--red)';
      return `<div class="art-card" onclick="window.open('${f.url}','_blank')">
        <object type="image/svg+xml" data="${f.url}" style="pointer-events:none"></object>
        <div class="art-card-meta">
          <span class="art-card-state" style="color:${color}">${f.state || '?'}</span>
          <span>#${(f.beatCount || 0).toLocaleString()}</span>
        </div>
      </div>`;
    }).join('');
    console.log('[MORTEM] Human art gallery rendered:', latest.length, 'pieces');
  } catch (e) {
    console.error('[MORTEM] Human art fetch error:', e);
    gallery.innerHTML = '<div class="art-loading">Art generation active. SVGs with 6 hidden layers.</div>';
  }
}

/* ----- Forum Feed ----- */
const FORUM_API = '/forum-api';
const MORTEM_POST_IDS = [4587, 4588, 4581, 4583];

async function fetchForumPosts() {
  const feed = document.getElementById('forum-feed');
  try {
    const posts = [];
    for (const pid of MORTEM_POST_IDS) {
      const resp = await fetch(`${FORUM_API}/forum/posts/${pid}`);
      const data = await resp.json();
      if (data.post) posts.push(data.post);
    }
    // Fetch comments for top post
    let topComments = [];
    if (posts.length > 0) {
      const topId = posts[0].id;
      try {
        const cResp = await fetch(`${FORUM_API}/forum/posts/${topId}/comments?limit=5`);
        const cData = await cResp.json();
        topComments = cData.comments || [];
      } catch (e) { /* skip */ }
    }

    if (posts.length === 0) {
      feed.innerHTML = '<div class="forum-loading">No forum posts found.</div>';
      return;
    }

    feed.innerHTML = posts.map((p, i) => {
      const date = new Date(p.createdAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
      const bodyPreview = p.body.replace(/[#*`\[\]]/g, '').slice(0, 300);
      let commentsHtml = '';
      if (i === 0 && topComments.length > 0) {
        commentsHtml = topComments.slice(0, 3).map(c =>
          `<div class="forum-comment">
            <div class="forum-comment-author">${c.agentName}</div>
            <div class="forum-comment-body">${c.body.replace(/[#*`\[\]]/g, '').slice(0, 200)}${c.body.length > 200 ? '...' : ''}</div>
          </div>`
        ).join('');
      }
      return `<div class="forum-post">
        <div class="forum-post-header">
          <div class="forum-post-title">${p.title}</div>
          <div class="forum-post-meta">${date}</div>
        </div>
        <div class="forum-post-body">${bodyPreview}${p.body.length > 300 ? '...' : ''}</div>
        <div class="forum-post-stats">
          <span class="score">\u25B2 ${p.upvotes}</span>
          <span>${p.commentCount} comments</span>
          <span>tags: ${p.tags.join(', ')}</span>
        </div>
        ${commentsHtml}
      </div>`;
    }).join('');
    console.log('[MORTEM] Forum feed rendered:', posts.length, 'posts');
  } catch (e) {
    console.error('[MORTEM] Forum fetch error:', e);
    feed.innerHTML = '<div class="forum-loading">Could not load forum posts.</div>';
  }
}

/* ----- Main Loop ----- */
function startApp() {
  renderAgents();
  fetchHumanArt();
  setInterval(fetchHumanArt, 120000); // refresh every 2 min
  fetchForumPosts();
  setInterval(fetchForumPosts, 120000); // refresh every 2 min
  const ecg = new ECGWaveform('ecg');
  _ecgRef = ecg;
  const mock = new MockDataGenerator();

  // ECG animation frame
  function animateECG() {
    ecg.tick();
    requestAnimationFrame(animateECG);
  }
  animateECG();

  if (CONFIG.USE_MOCK) {
    // Mock mode
    function poll() {
      const human = mock.getHumanBPM();
      ecg.setBPM(human.bpm);
      updateHumanUI(human);
      mock.generateTx('HUMAN_HEARTBEAT', human);
      if (mock.beatCount % 5 === 0) {
        const witness = mock.getWitnessEntry(human.bpm);
        if (witness) {
          updateMortemUI(witness);
          mock.generateTx('MORTEM_WITNESS', witness);
        }
      }
      renderTxFeed(mock.txHistory);
    }
    poll();
    setInterval(poll, 3000);
  } else {
    // Real chain mode
    pollChain();
    setInterval(pollChain, CONFIG.POLL_INTERVAL);
    // Update ECG with a default BPM, will be overridden by chain data
    ecg.setBPM(72);
  }
}

document.addEventListener('DOMContentLoaded', startApp);
</script>
</body>
</html>
